Как управлять радио через iPhone

Кто сейчас вообще слушает радио? Может показаться, что в современном мире не осталось места для радио, однако мы сумели отыскать несколько кейсов его реального использования и немного поиграли с этим:

[video]

В этой статье мы хотели бы рассказать, как не будучи радиотехниками, можно реализовать механизм удаленного управления радиовещанием, а заодно раскрыть техническую составляющего происходящего в видео.

<habracut/>

История этого проекта сложилась довольно неординарно: мы хотели в короткие сроки реализовать управляемый с мобильного устройства fm-передатчик, связав полностью готовые компоненты между собой и особо не погружаясь в радиотехнику, но в итоге получили опыт hardware-reversing. 

Кратко наш путь выглядит так:

1. Уровень 0: `git clone fm_transmitter`
2. Уровень 1: поиск готовых систем fm-вещания для дальнейшей модификации
3. Уровень 2: железный хакинг

# Уровень 0: `git clone fm_transmitter`

Часто для того, чтобы понять, как нужно делать что-то правильно, нужно просто начать это делать. Мы начали с поиска существующих проектов в GitHub по управлению fm-передачей (google: `site:github.com "fm transmitter"`). И сразу же вышли на живой проект - https://github.com/markondej/fm_transmitter, позволяющий вещать радио посредством GPCLK (General Purpose Clock) пина с Raspberry PI. Протестировав работоспособность проекта на реальном радио и услышав свою мелодию вместо оригинальной радиостанции, на минуту показалось, что дело сделано и задачу в Jira вот-вот можно закрывать.

Оставалось только придумать интерфейс взаимодействия с RPi. Выбрали классический в мире IoT подход: WiFi AP + веб-приложение. Во вселенной Opensource был быстро найден подходящий проект [rpi-hostap](https://github.com/sdelrio/rpi-hostap), позволяющий в пару кликов разернуть WiFi Access Point с нужной конфигурацией на Raspbian и с веб-приложением внутри локальной сети AP (со статическим IP), к которому бы стучалось iOS-приложение, управляющее радио.

### +Веб-приложение

MVP веб-приложения был реализован на базе Python-фреймворка Flask и содержит следующие HTTP-эндпоинты для управления вещанием:

* `/setfreq?freq=<частота вещания в Mhz>` - установка нужной fm-частоты
* `/start&audio=<название>` - запуск вещания выбранного аудио на ранее заданной частоте
* `/stop` - остановка вещания
* `/seek?perc=<% проигрывания>` - промотка аудио на нужное место
* `/repeat?enable=<bool>` - включение/отключение повторения при завершении аудио
* `/sync` - получение текущей информации о ходе проигрывания
* `/upload` - загрузка нового аудио

Веб-интерфейс не предполагалось использовать в многопользовательском режиме, однако для надежности все методы были защищены общим `threading.Lock`-объектом: одновременно можно было вызывать только какой-то один из методов.

### +Мобильное приложение

После появления http-интерфейса уже можно было общаться с RPi множеством различных способов. Нашей конечной целью было управление fm-вещанием через iPhone:

[скриншот выбора частоты]
[скриншот выбора аудио]

На этом этапе у нас был полностью готовый прототип fm-трансмиттера с интерфейсом, позволяющим его легко тестировать в разных локациях. До текущего момента все тесты проходили в помещении офиса, что давало дальность вещания до 20 метров. Но после серии уличных тестов выяснилось, что даже 5-метровый радиус получается гарантировать не всегда... 

### +Удлинение GPIO-антенны

Мы стали пытаться увеличить дальность вещания путем удлинения GPIO-антенны, отходящей от GPCLK-пина:

[фото длинной антенны-провода]

Увеличение дальности произошло, но оказалось незначительным (в пределах нескольких метров).

### -Удлинение GPIO-антенны + стереоскопическая антенна

Для еще большего увеличения дальности решили попробовать стереоскопическую антенну. Чтобы её использовать, был необходим переход с GPIO пина на контур антенны. В этот момент мы расчехлили паяльник, но пока не подозревали, что станем с ним неразлучны до конца проекта. Получилось спаять вот такой "переходник":

[фото переходника GPIO-папа]

Это дало результат как минимум не хуже предыдущего, но теперь стало удобнее эксплуатировать антенну.

### +Усилитель для стереоскопической антенны

Было очевидно, что GPCLK-пин Rasberry "не вытянет" нужной мощности без дополнительной помощи. Спустя несколько консультаций с внешними экспертами выяснилось, что такая "помощь" существует - [SPF5189Z](https://aliexpress.ru/item/32949198452.html). Это усилитель сигнала, использующий внешнее питание. Добавили этот компонент в разрыв между переходником и антенной:

[фото усилителя + антенны]

Снова достали паяльник для пайки переходника для запитывания усилителя через USB с того же Powerbank, с которого питался RPi, после чего "аккуратно" разместили все в картонной коробке для удобства эксплуатации:

[фото коробки]

На этот раз дальность вещания была увеличена с нестабильных 10 метров до стабильных 15 метров на улице, чего с натяжкой хватало.

### Finale: -fm_transmitter

Вся эта конструкция проработала ровно 1 день, пока не перегорел усилитель. В этот момент пришло осознание, что мы далеко отошли от исходной идеи сборки устройства из готовых компонентов без погружения и что без минимального погружения в радиоэлектронику не обойтись.

# Уровень 1: поиск готовых систем fm-вещания для дальнейшей модификации

"Уровень 0" привнес интерфейс управления, независимый от железа, поэтому мы могли смело отказаться от использования проекта `fm_transmitter` и поискать другой способ организации fm-вещания. 

У нас не было желания строить собственный велосипед из fm-вещателя и усилителя, поэтому мы решили отыскать готовую систему и немного её "подпилить". Небольшая разведка привела нас к китайской компании CZERF, занимающейся беспроводными технологиями. В ассортименте продуктов, выпускаемой данной компанией, было обнаружено интересное устройство - fm-трансмиттер на 7 ватт с кнопочным управлением (2 кнопки на выставлени частоты ▲/▼ и 1 кнопка питания) и audio-jack'ом - [CZERF-7C](https://aliexpress.ru/item/1005001499071696.html) (официальный сайт кидается 500 ошибкой). Такая мощность позволила бы в десятки раз увеличить дальность в условиях улицы. Задача сводилась к связыванию проприетарного прибора малоизвестной китайской компании с RPi.

Получили прибор на руки, сразу же его разобрали и приступили к анализу основной платы. За несколько часов с помощью мультиметра удалось установить связь между дорожками кнопок и микроконтроллером, связывающего дисплей, кнопки и радиомодуль воедино на этом устройстве. 

[фото контроллера]

### +RPi Relay Board

Под рукой уже был разогретый Raspberry PI с "Уровня 0", поэтому мы пришли к идее имитации нажатий на кнопки устройства с помощью [GPIO-реле](https://www.chipdip.ru/product/rpi-relay-board). Это реле предоставляло очень удобный интерфейс управления - достаточно насадить реле на GPIO-шину RPi, после чего посылать сигнал на один из пинов GPIO Raspberry, как нужное реле замыкает цепь подобно оригинальной кнопке:

```
RPi.GPIO.output(PIN, RPi.GPIO.HIGH)
time.sleep(0.03) # минимальное удерживания кнопки, которое воспринимает контроллер
RPi.GPIO.output(PIN, RPi.GPIO.LOW)
time.sleep(0.03)
```

Потребовалась серьезная переработка веб-приложения (без изменения http-интерфейса): теперь при вызове `/setfreq`(установка частоты) нужно было запускать фоновую задачу по "натыкиванию" нужной частоты, а при вызове `/start`(запуск проигрывания) - запускать фоновое аудио, которое бы по audio-jack уходило бы в радиомодуль (до этого аудио-сэмплы читались из файла без непосредственного проигрывания). 
За дальность вещания пришлось расплатиться скоростью выставления частоты - за одну имитацию нажатия на управляющие кнопки происходило изменение частоты на 100kHz. Если, например, нужно с частоты 90Mhz переключиться на 105Mhz, потребовалось бы ждать `(105-90)*10*(0.03*2)=9` секунд. Вдобавок к этому появилось щелканье реле на протяжении всего времени переключения частоты и необходимость запоминания частоты программно, т.к из кода не было никакой связи с реальной("железной") частотой на устройстве.

Но тем не менее самой большой проблемой оказалось другое - наводки. 7-ваттная антенна fm-вещателя нагревала провода на расстоянии своим излучением. А на реле это сказывалось следующим негативным образом: в какие-то редкие моменты могли происходить случайные переключения частоты вверх или вниз из-за наводок. С учетом отсутствия обратной связи с "железной" частотой, код мог "думать", что нужная частота "нащелкана", когда на самоме деле нет.

С этого момента наводки, как и паяльник, сопровождали нас до заключительной стадии проекта.

### -RPi Relay Board + Оптроны

Было решено начать избавляться от кома образовавшихся проблем постепенно и методично. Начали с того, что к текущему моменту надоело больше всего - с устранения треска реле.

**... Женя:
-избавились от щелканья при переключении частоты @Евгений Чормонов  
-остались наводки на переключатель частоты
-(рассказать, почему выбрали именно оптроны, принцип их работы)
-(графическая схема макетной "платы на проводах")
-(фото "платы на проводах")
...**

### +Плата_v1 + Экранированный провод + 3d-каркас

Следующей проблемой после треска реле были наводки. На этом этапе не было никаких сомнений, что "плата на проводах" есть основной субъект наводок. Поэтому все силы mskb брошены на разработку полноценной платы управления, которая схематично была практически аналогична "плате на проводах".

**... Женя:
-ушли наводки произвольного переключения частоты
-появились наводки непереключения частоты в ходе вещания
-(описание отличий от макетной платы - какие функции появились)
-(описание хода проектирования платы с графическими схемами)
-(выбор места для печати платы)
-(разработка экранированного провода для собственной платы с фото)
-(решили избавиться от конденсаторов, т.к думали, что наводки на провода и убрали реле)
-(описать структуру 3d-каркаса с фото - только финальный вариант)
...**

### +Оптрон управления вещанием - Плата_v1 + Плата_v2

Наводки, провоцирующие произвольное переключение частоты, ушли, но появились другие - теперь частота переключалась не всегда, когда было нужно в ходе вещания. 

Провели командный брейншторм, общий посыл которого был таков: "нужно найти способ устранения наводок, не требующий еще большего углубления в радиотехнику". Идеальным вариантом было бы обойтись уже полученными в ходе проделанной работы знаниями. И такой способ нашелся. Мы вспомнили, что к микроконтроллеру, связывающему кнопки и дисплей с радиомодулем, ведут целых 10 ножек, в то время, как мы знали назначение только 4 из них. Управлять любой другой из них через оптрон - уже знакомый нам способ. Одна из ножек наверяка должна отвечать за питание самого радиомодуля, ответственного за вещание. Мы достали мультиметр и быстро вычислили эту ножку. Оказалось, можно не отключая питание всего устройства, включать/выключать вещание, когда это нужно. А значит у нас появилась возможность выставлять частоту до активного вещания, что позволит избавиться от остаточных наводок "непереключения". После пары экспериментов выяснилось, что память(текущая fm-частота) находится в микроконтроллере, а не в радиомодуле, поэтому, отключая питание радиомодуля, мы можем спокойно "нащелкать" нужную частоту на контроллере, а после подачи питания на радиомодуль (включение вещания) контроллер сам отправит в радиомодуль итоговую частоту.

**... Женя:
-наводки на переключатель частоты ушли полностью
-появилась наводка на управление питанием трансмиттера - подобрали таймаут 0.05 секунд
-долгое переключение частоты
-обнаружен эффект "разогрева" вещателя в 4 секунды (надо ждать выставления частоты)
-(принцип работы ножки вещания, за что еще она отвечает - связь с радиомодулем)
-(описание хода проектирования платы с графическими схемами)
-(описать, как выявили природу наводки на включение питания и как ее устранили)
...**

### +Конденсаторы (?)

Избавившись от наводок на переключатели частоты, но приобретя наводки на включение/выключение питания устройства, мы оказались в тупиковой ситуации. Было очевидно, что решение проблемы нами отодвигается, но не решается.

Необходимо было остановиться и подумать. Спустя пару дней самостоятельные изыскания привели нас к такому интересному компоненту, как конденсатор. Точнее, к разновидности его использования - блокировочному конденсатору. Для нас это стало окончательным решением проблем наводок - если в ходе вещания возникает импульс, способный помешать имитации нажатия на кнопку, то этот импульс можно "срезать", поставив по конденсатору на каждую кнопку. 

## Finale: -управление через кнопки

К этому моменту fm-вещатель был уже существенно модифицирован: все кнопки управлялись программно с RPi и даже была добавлена дополнительная "кнопка" на управление самим вещанием. Все работало достаточно стабильно, но долго выставлялась частота и оставалась потенциальная возможность возвращения наводок в процессе имитации нажатий.

Мы обратили внимание, что наводки влияют только на те элементы, на пути которых встречаются кнопки. Так, на включение/выключение вещания, которым управлял только наш оптрон, наводки не влияли. 

В итоге было решено окончательно погрязнуть в азах радиоэлектроники с целью стабилизации работы устройства, отказаться от "натыкивания" частоты и окунуться в мир hardware-reversing'а.

# Уровень 2: Железный хакинг

В предыдущем уровне мы решили углубиться и разобраться в устройстве нашего передатчика. Интерфейс кнопок оказался ненадежен и не быстр. Нужно от него отказаться и найти другой интерфейс выставления частоты. Для этого нужно разобраться, как микроконтроллер выставляет на радиомодуле частоту, какие ножки используется и какие сигналы посылаются.

### +Осциллограф

Из исследований предыдущих уровней. У нас остались неизвестными 4 ножки платы микроконтроллера.
![фото ножек](https://github.com/Rolariali/picture/raw/main/left_pin_fm.png)
Давайте разберемся, что на них происходит при переключении частоты. Подключимся поочередно щупами осциллографа к ним (землю осциллографа нужно подключить к земле трансмиттера) и будем зажимать кнопки переключения частоты в верх или низ, чтобы инициализировать обмен между микроконтроллером и радиомодулем.

Мы использовали USB-осциллограф Hantek DSO-6022BL. Очень рекомендую его использовать не с родной программой от производителям(которая только под Windows), а с open-source проектом [openhantek](http://openhantek.org/)(на Macos ставится через Brew). При измерении USB-осциллографом, fm-трансмиттер питать лучше от аккумулятора, а не от сети. Также нужно будет еще заэкранировать антенну fm-передатчика, чтобы она не давала наводки на щупы осциллографа ( а от антенны еще страдает и USB интерфейс hantek'a в виде периодических отваливаний и зависаний). Экранирование антенны делали медной сеткой, причем требуется не только плотно замотать антенну, но обеспечить надежный контакт сетки с корпусом прибора.
![фото замотки](https://)
    
На ножке №1 никакой активности нет, на остальных можно увидеть сигналы, которые посылает микроконтроллер в радиомодуль.
![](https://github.com/Rolariali/picture/raw/main/cs-clk.png)
![](https://raw.githubusercontent.com/Rolariali/picture/main/clk-mosi1.png)

### +SPI интерфейс


Захваченные сигналы очень похоже на протокол [SPI](https://ru.wikipedia.org/wiki/Serial_Peripheral_Interface).
Кратко как работает этот простой протокол, который придумали еще в прошлом веке.
Есть три линии данных, называемых CS, MOSI, CLK.
![CLK MOSI](https://github.com/Rolariali/picture/raw/main/clk-mosi.png)
CS - chip select, на этой линии выставляется низкий или высокий уровень, который говорит приемнику SPI(в нашем случае это радиомодуль), что пока выставлен уровень, будет происходить передача данных на линии MOSI и передача синхроимпульсов на линии CLK. Вообще обычно разрешающим сигналом для CS является низкий уровень (еще никогда не встречал микросхемы с разрешающим высоким уровнем), а здесь радиомодуль использует высокий уровень сигнала, что несколько странно(дальше будет понятно почему разработчики так сделали в дальнейшем)
по CLK линии идут синхроимпульсы, которые говорят приемнику SPI, в какой момент делать считывание данных на линии MOSI. Данные могут считывается по переднему или заднему фронту импульса (а иногда и по обоим фронтам одновременно).
В данном случаем происходит считывание по переднему фронту. В посылке можно увидеть, что данные меняются по заднему фронту, значит задний фронт не используется для считывания данных - по протоколу данные **не** могут меняться при считывающем фронте. Лучше всего это видно на этом захвате сигнала (сделан мной в родной программе для осциллографов Hantek)

![](https://github.com/Rolariali/picture/raw/main/fail_front.png)
Внизу зеленый сигнал - это MOSI, желтый вверху - CLK

![фото ножек](https://github.com/Rolariali/picture/raw/main/left_pin_fm.png)
Исходя из выше сказанного ножка 2 - это CS, 3 - CLK, 4 -DATA

### +Расшифровываем "трафик"
Давайте перехватим парочку посылок с разными частотами

Частота 102.6 Мгц
![](https://raw.githubusercontent.com/Rolariali/picture/main/1026.png)
Частота 102.4 
![](https://raw.githubusercontent.com/Rolariali/picture/main/1024.png)
Частота 92.9
![](https://raw.githubusercontent.com/Rolariali/picture/main/929.png)

Можно заметить, что у этих сообщений не меняется хвостовая чать, последние 5 бит 0b10010
![](https://raw.githubusercontent.com/Rolariali/picture/main/end_mark.png)
Скорее всего это команда, которая устанавливает частоту, а данные о частоте передаются в первых 11 битах.
Рассмотрим две ближлежащие частоты 102.4 и 102.6 Мгц
102.4 Мгц
![](https://github.com/Rolariali/picture/raw/main/1024-bits.png)
102.6 Мгц
![](https://github.com/Rolariali/picture/raw/main/1026-bits.png)
Можно заметить что разница есть только в одном бите, что идет в начале - скорее всего здесь находятся младшие биты значения частоты. Давайте попробуем переписать эту битовую последовательность в обратном порядке, с права на лево:
**102.4**: ```10000000000```
**102.6**: ```10000000010```
Переведем для удобства воприятия в десятичный формат...
**102.4**: ```1024```
**102.6**: ```1026```
Вот так вот просто, не может быть, а если взять частоту 92.9
битовая последовательность в посылке **92.9**:```110000101110```
Обратная битовая последовательность **92.9**: ```011101000011```
Десятичное представление обратной последовательности **92.9**: ```929```

Можно сказать, что разбор протокола на этом завершен. Теперь надо откусить ножки CS, CLK, MOSI от головного микрконтроллера, подцепить их ардуинке и попробовать отправить с нее команды.

### +Arduino. Установка частоты
![фото ардуинки](https://)

И очень простой скетч:
```c-like=
#include <SPI.h>

void setup (void)
  {
    // иницилизация SPI контроллера на arduino
    SPI.begin();
    // Выставление частоты работы CLK, здесь ставится максимальный делитель частоты 128.
    // Частота работы ардуино 16 000 000 Гц. Значит чатоста синхроимпульсов будет 16 000 000/128 = 125 000 Гц
    SPI.setClockDivider(SPI_CLOCK_DIV128);
    
    // Установка режима работы SPI. Ниже, в статье будет разбор режимов работы
    SPI.setDataMode(SPI_MODE0);
  } // end of setup

void loop (void)
  {
      // Выставлляем высокий уровень на CS, ножка 10
      // Иницилизируем окно передачи сообщения по SPI
      digitalWrite(SS, HIGH);

      const unsigned int freq = 0b0000000000110010;  // 102.4 Mhz
    
      // Передаем сообщение с частотой, сообщение у нас состоит из 11 бит значения частоты и 5 бит команды;
      // Всего 16 бит. Значит нужно использовать ф-цию для передачи 16 бит transfer16
      // https://www.arduino.cc/en/Reference/SPITransfer
      SPI.transfer16(freq);

      // Выставлляем низкий уровень на CS, ножка 10
      // Закрываем окно передачи данных по SPI
      digitalWrite(SS, LOW);
    
      delay (20000);  // 20 sсекунд ждем
  } // end of loop
  ```
 Код до безобразия прост, но стоит наверно пояснить один момент с режимом работы SPI. Для SPI есть несколько режимов работы SPI. Они отличаются фронтом считывания ( передний или задний, на картинке ниже они показаны стрелочками) и начиная с какого уровня стартует сигнал CLK (высокий или низкий)
 ![](https://i.stack.imgur.com/MHkRd.png)
 Для нашего случая подходит режим *Mode 0*, поэтому в настройках SPI:
 ```SPI.setDataMode(SPI_MODE0);```

Запускаем на ардуине и видим как каждые 20 секунд у нас устанавливается частота 102.4 Мгц. Можно менять константу freq и частота после перезаливки скетча в ардуино будет меняться.

### -Arduino +Rpi
Теперь попробуем тоже самое сделать на RPi. RPi будет подключаться через оптроны, по следующей схеме

![](https://github.com/Rolariali/picture/raw/main/rasp_spi_opto_v1.png)

Накидаем для проверки небольшой скрипт, аналогичный нашему скетчу выше:
```python=
import spidev
import time

spi = spidev.SpiDev()
spi.open(bus=0, device=0)
spi.max_speed_hz = 2000 # на боллее низкий частоте не может работать аппаратный SPI
spi.mode = 2
While True:
    spi.xfer2([~0x00, ~0x32]) # отправка частоты 1024
    time.sleep(20)
spi.close()
```

Для работы через оптроны нужно поменять режим работы SPI на *Mode 2*. Это связно с тем, что сигнал на оптронах инвертируется. По этой же причине мы по линии MOSI отправляем инвертированные значения 
```[~0x00, ~0x32] = 0b1111111111001101```
Вместо 0b0000000000110010

Подсоединяем, запускаем и ничего не работает. Лезем осциллографом смотреть какой сигнал у нас формируется после оптронов. Что бы посмотреть сигнал, нужно снова оборачивать в экран антенну... И в этом случаем все начинает работать. Значит наводки от антены искажают наш сигнал. Давайте воспользуемся старым приемом и будем выключать вещание, для выставления частоты. Алгоритм получается следующий:
1. Выключить питание радиомодуля
2. Включить питание радиомодуля
3. Выставить частоту

Пробуем такой алгоритм, все хорошо, но только в половине случаев. Частота устанавливается через раз...

Помните до этого упоминалось, что сигнал CS имеет не типичную полярность... После долгого разбирательства с явлением установки частоты через раз, стало ясно почему разработчики этого fm-трасмитера выбрали такую полярность.

Паразитное питание:
![](https://github.com/Rolariali/picture/raw/main/parazite.png)
При выключение радиомодуля, он начинал через встроенные защитные диоды подпитываться от ножек CS, CLK, MOSI. По этой причине разработчики fm-трансмиттера, все линии SPI вне посылки сообщений притягивают к низкому уровню. У контроллера SPI в RPi, линия MOSI после отправки сообщения выставлялся в низкий уровень, а так как сигнал на оптронах инвертируется - на линии MOSI радиомодуля оказывался высокий уровень, который "паразитно" подпитывал радиомодуль и не давал ему полноценно выключатся. Когда подавлась полноценное питание на радиомодуль, он начинал сразу вещать на частоте, которую ему установили до этого и тем самым создавать наводки на линии SPI от RPi.

### -Аппаратный SPI +Собственная реализация протокола

Казалось бы нужно просто выставлять MOSI в высокий уровень после каждой отправки сообщения, но это оказалось не просто. В настройках SPI не удалось найти такого ф-ционала, а если потом линию MOSI иницилизировать как обычный GPIO пин, то переставал работать аппаратный SPI до перезагрузки системы на RPi. Самым простым и быстрым решением было реализовать програмный SPI через прямое выставление уровней на ножках GPIO. Реализация получилась очень простая:
```python=
    def _clock(self):
		GPIO.output(self.CLK, GPIO.HIGH)
		time.sleep(0.001)
		GPIO.output(self.CLK, GPIO.LOW)

	def _send(self, bits):
		GPIO.output(self.CS, GPIO.LOW)
		time.sleep(0.001)
		for bit in bits:
			GPIO.output(self.MOSI, GPIO.HIGH if bit else GPIO.LOW)
			self._clock()
			time.sleep(0.001)
		GPIO.output(self.CS, GPIO.HIGH)

```

### -Плата микроконтроллера +Плата_v3
И больше проблем с выставлением частоты мы не имели. Осталось выкинуть плату микроконтроллера и заменить ее своей, уже третьей версией. Для того что бы это сделать, нужно только выяснить за что отвечает ножка №1
Скорее всего она отвечает за режим работы fm-трансмиттера: вещание с мощностью 1 или 7 Ватт. Проверим это, в настройках выставим Hight режим, на этой ножке будет низкий уровень(0В), если выставить Low режим, будет высокий уровень (5В).
С учетом этой информации, собираем новую схему:
![](https://github.com/Rolariali/picture/raw/main/opto3_f.png)

Здесь помимо выставления частоты, есть возможность выставить режим работы в режиме 1 Ватт и 7 Ватт и добавлены светодиоды для отладки схемы 
![](https://github.com/Rolariali/picture/raw/main/led_3.png)

### выводы